<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器相关 | Jinle Blog</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="this is my blog">
    <meta name="author" content="Jinle">
    <meta name="keywords" content="Jinle，博客">
    
    <link rel="preload" href="/blog/assets/css/0.styles.6a057b61.css" as="style"><link rel="preload" href="/blog/assets/js/app.bfa839b2.js" as="script"><link rel="preload" href="/blog/assets/js/2.645db33a.js" as="script"><link rel="preload" href="/blog/assets/js/24.8b11f7a9.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.9c8a1f5b.js"><link rel="prefetch" href="/blog/assets/js/11.c298643d.js"><link rel="prefetch" href="/blog/assets/js/12.427a10fc.js"><link rel="prefetch" href="/blog/assets/js/13.be77fcd1.js"><link rel="prefetch" href="/blog/assets/js/14.f37c6f32.js"><link rel="prefetch" href="/blog/assets/js/15.d0c9f0d9.js"><link rel="prefetch" href="/blog/assets/js/16.29bd1750.js"><link rel="prefetch" href="/blog/assets/js/17.23b38649.js"><link rel="prefetch" href="/blog/assets/js/18.8f6226ec.js"><link rel="prefetch" href="/blog/assets/js/19.f5f11d8b.js"><link rel="prefetch" href="/blog/assets/js/20.cb070a76.js"><link rel="prefetch" href="/blog/assets/js/21.f4d465d2.js"><link rel="prefetch" href="/blog/assets/js/22.d2749c0c.js"><link rel="prefetch" href="/blog/assets/js/23.87c08510.js"><link rel="prefetch" href="/blog/assets/js/25.9400e42a.js"><link rel="prefetch" href="/blog/assets/js/26.052c5410.js"><link rel="prefetch" href="/blog/assets/js/27.567369c3.js"><link rel="prefetch" href="/blog/assets/js/3.7d8e4f36.js"><link rel="prefetch" href="/blog/assets/js/4.ac928f4c.js"><link rel="prefetch" href="/blog/assets/js/5.3bee8350.js"><link rel="prefetch" href="/blog/assets/js/6.80fd9f1e.js"><link rel="prefetch" href="/blog/assets/js/7.76822249.js"><link rel="prefetch" href="/blog/assets/js/8.02e5baef.js"><link rel="prefetch" href="/blog/assets/js/9.eb5fc156.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.6a057b61.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Jinle Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/frontend/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="https://jinle0703.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  随笔
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/JINLE0703/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/blog/frontend/" class="nav-link router-link-active">
  前端
</a></div><div class="nav-item"><a href="https://jinle0703.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  随笔
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/JINLE0703/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/blog/frontend/" aria-current="page" class="sidebar-link">HTML</a></li><li><a href="/blog/frontend/CSS.html" class="sidebar-link">CSS</a></li><li><a href="/blog/frontend/JavaScript.html" class="sidebar-link">JavaScript</a></li><li><a href="/blog/frontend/React.html" class="sidebar-link">React</a></li><li><a href="/blog/frontend/React相关库.html" class="sidebar-link">React相关库</a></li><li><a href="/blog/frontend/Vue.html" class="sidebar-link">Vue</a></li><li><a href="/blog/frontend/TypeScript.html" class="sidebar-link">TypeScript</a></li><li><a href="/blog/frontend/Node.html" class="sidebar-link">Node</a></li><li><a href="/blog/frontend/Koa.html" class="sidebar-link">Koa</a></li><li><a href="/blog/frontend/微信小程序.html" class="sidebar-link">微信小程序</a></li><li><a href="/blog/frontend/浏览器相关.html" class="active sidebar-link">浏览器相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#浏览器进程" class="sidebar-link">浏览器进程</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#导航流程" class="sidebar-link">导航流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#http-请求过程" class="sidebar-link">HTTP 请求过程</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#优化资源请求" class="sidebar-link">优化资源请求</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#渲染流程" class="sidebar-link">渲染流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#生成-dom-树" class="sidebar-link">生成 DOM 树</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#渲染机制" class="sidebar-link">渲染机制</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#重排" class="sidebar-link" style="padding-left:3rem;">重排</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#重绘" class="sidebar-link" style="padding-left:3rem;">重绘</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#合成" class="sidebar-link" style="padding-left:3rem;">合成</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#优化渲染" class="sidebar-link">优化渲染</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#事件循环" class="sidebar-link">事件循环</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#event-loop-机制" class="sidebar-link">Event-Loop 机制</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#for-of" class="sidebar-link">for...of</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#执行顺序" class="sidebar-link">执行顺序</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#缓存机制" class="sidebar-link">缓存机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#缓存存放位置" class="sidebar-link">缓存存放位置</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#强制缓存" class="sidebar-link">强制缓存</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#expires" class="sidebar-link" style="padding-left:3rem;">Expires</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#cache-control" class="sidebar-link" style="padding-left:3rem;">Cache-Control</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#协商缓存" class="sidebar-link">协商缓存</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#last-modified-if-modified-since" class="sidebar-link" style="padding-left:3rem;">Last-Modified / If-Modified-Since</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#etag-if-none-match" class="sidebar-link" style="padding-left:3rem;">Etag / If-None-Match</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#总体过程" class="sidebar-link">总体过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#客户端存储" class="sidebar-link">客户端存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#cookie" class="sidebar-link">cookie</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#session" class="sidebar-link">session</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#localstorage" class="sidebar-link">localStorage</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#sessionstorage" class="sidebar-link">sessionStorage</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#跨域" class="sidebar-link">跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#同源策略" class="sidebar-link">同源策略</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#jsonp" class="sidebar-link">JSONP</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#cors-跨域资源共享" class="sidebar-link">CORS（跨域资源共享）</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#简单请求" class="sidebar-link" style="padding-left:3rem;">简单请求</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#非简单请求" class="sidebar-link" style="padding-left:3rem;">非简单请求</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#document-domaim" class="sidebar-link">document.domaim</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#postmessage" class="sidebar-link">postMessage</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#发送" class="sidebar-link" style="padding-left:3rem;">发送</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#接收信息" class="sidebar-link" style="padding-left:3rem;">接收信息</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#服务端代理" class="sidebar-link">服务端代理</a></li><li class="sidebar-sub-header"><a href="/blog/frontend/浏览器相关.html#websocket" class="sidebar-link">WebSocket</a></li></ul></li></ul></li><li><a href="/blog/frontend/前端工程化.html" class="sidebar-link">前端工程化</a></li><li><a href="/blog/frontend/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/blog/frontend/前端安全.html" class="sidebar-link">前端安全</a></li><li><a href="/blog/frontend/性能优化.html" class="sidebar-link">性能优化</a></li><li><a href="/blog/frontend/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/blog/frontend/数据结构.html" class="sidebar-link">数据结构</a></li><li><a href="/blog/frontend/算法.html" class="sidebar-link">算法</a></li><li><a href="/blog/frontend/WebSocket.html" class="sidebar-link">WebSocket</a></li><li><a href="/blog/frontend/操作系统.html" class="sidebar-link">操作系统</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="浏览器进程"><a href="#浏览器进程" class="header-anchor">#</a> 浏览器进程</h2> <ul><li>浏览器进程 --- 主要负责用户交互、子进程管理和文件储存等功能</li> <li>网络进程 --- 是面向渲染进程和浏览器进程等提供网络下载功能</li> <li>渲染进程 --- 主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。所以 Chrome 会让渲染进程运行在安全沙箱里，为了保证系统的安全</li> <li>GPU 进程 --- 绘制 UI 界面</li> <li>插件进程 --- 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响</li></ul> <h2 id="导航流程"><a href="#导航流程" class="header-anchor">#</a> 导航流程</h2> <p>用户发出 URL 请求到页面开始解析的这个过程</p> <p><img src="https://raw.githubusercontent.com/jinle0703/img-host/master/blog/%E8%BE%93%E5%85%A5URL%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="导航流程图"></p> <ol><li>用户地址栏输入
<ol><li>输入关键字搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL</li> <li>输入内容符合 URL 规则，地址栏会根据规则，把这段内容加上协议，合成为完整的 URL</li></ol></li> <li>URL 请求过程
<ol><li>浏览器进程通过进程间通信把 URL 请求发送至网络进程</li> <li>网络进程会查找本地缓存是否缓存了该资源。有缓存直接返回资源，没缓存进入网络请求流程</li> <li>DNS 解析 获取 IP 地址</li> <li>建立 TCP 连接，三次握手</li> <li>向服务器发送请求</li> <li>服务器返回响应数据，网络进程接收并解析</li> <li>重定向问题
<ol><li>服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航</li> <li>响应行是 200，那么表示浏览器可以继续处理该请求</li></ol></li> <li>响应数据类型处理（Content-Type）
<ol><li>Content-Type 字段的值被浏览器判断为 <strong>下载类型（如：application/octet-stream）</strong>，该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</li> <li>如果是 HTML，那么浏览器则会继续进行导航流程</li></ol></li></ol></li> <li>准备渲染进程
<ol><li>通常情况下，打开新的页面都会使用单独的渲染进程</li> <li>如果从 A 页面打开 B 页面，且 A 和 B 都属于 <strong>同一站点</strong> 的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程</li></ol></li> <li>网络进程提交文档给渲染进程
<ol><li>文档指的是 URL 请求的响应体数据</li> <li>浏览器进程发出提交文档的消息，渲染进程接收到提交文档的消息后，和网络进程建立传输数据的 <strong>管道</strong></li> <li>等文档数据传输完成之后，渲染进程会返回 <strong>确认提交</strong> 的消息给浏览器进程</li> <li>浏览器进程在收到确认提交的消息后，<strong>更新浏览器界面状态</strong>，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面</li></ol></li> <li>随后进入渲染阶段</li></ol> <h3 id="http-请求过程"><a href="#http-请求过程" class="header-anchor">#</a> HTTP 请求过程</h3> <p><img src="https://raw.githubusercontent.com/jinle0703/img-host/master/blog/http%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt="http请求流程图"></p> <ol><li>浏览器构建请求行信息，准备发起网路请求</li> <li>浏览器在缓存中查找是否有请求的文件
<ol><li>浏览器发现资源存在缓存中，则拦截请求，返回资源副本，并结束请求（<strong>缓解服务器端压力，提升性能，实现快速资源加载</strong>）</li> <li>查找失败，则进入网路请求</li></ol></li> <li>准备 IP 和端口
<ol><li>浏览器请求 DNS 返回域名对应的 IP（<strong>浏览器提供 DNS 数据缓存服务，可减少一次网络请求</strong>）</li> <li>获取端口号，http 默认 80 端口，https 默认 443 端口</li></ol></li> <li>等待 TCP 队列，Chrome 浏览器同一域名最多 6 个 TCP 连接，超出需排队等待</li> <li>建立 TCP 连接，三次握手</li> <li>发送 HTTP 请求，浏览器向服务器发送请求行（请求方法、请求 URI、HTTP 版本协议）和请求头</li> <li>服务端处理 HTTP 请求后，返回响应行（协议版本、状态码）、响应头（返回数据类型、cookie 等信息）和响应体数据</li> <li>断开连接，除非头信息中有 <code>Connection:Keep-Alive</code>，则 TCP 保持连接打开，可发送多个请求（<strong>节省连接时间，提升资源加载速度</strong>）</li></ol> <h3 id="优化资源请求"><a href="#优化资源请求" class="header-anchor">#</a> 优化资源请求</h3> <p>关键资源 --- 能阻塞网页首次渲染的资源（HTML、CSS、JS）</p> <ol><li>减少关键资源个数
<ol><li>JS 和 CSS 改为内联形式</li> <li>JS 改为异步引入（sync、defer）</li></ol></li> <li>减少关键资源大小，如压缩资源</li> <li>减少 <strong>RTT（发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延</strong>） 次数</li> <li>CDN 加快网络请求</li></ol> <h2 id="渲染流程"><a href="#渲染流程" class="header-anchor">#</a> 渲染流程</h2> <p><img src="https://raw.githubusercontent.com/jinle0703/img-host/master/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="渲染流程图"></p> <ol><li>渲染进程构建 <strong>DOM 树</strong> <ol><li><strong>输入内容</strong> 是一个非常简单的 HTML 文件</li> <li>经由 HTML 解析器 <strong>解析</strong></li> <li><strong>输出</strong> 树状结构的 DOM</li></ol></li> <li>渲染引擎转换 CSS 样式表为 <strong>styleSheets</strong>，计算 DOM 节点样式
<ol><li>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 <strong>styleSheets</strong>，该结构具备查询和修改功能</li> <li>转换样式表中属性值为 <strong>渲染引擎容易理解的、标准化的计算值</strong></li> <li>计算 DOM 树中每个节点的具体样式（继承规则和层叠规则）</li></ol></li> <li>创建 <strong>布局树</strong>，计算元素的布局信息
<ol><li>创建布局树，遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；不可见的节点会被布局树忽略掉</li> <li>计算布局树节点的坐标位置</li></ol></li> <li>对布局树进行分层，渲染引擎生成 <strong>图层树（LayerTree）</strong> <ol><li>拥有 <strong>层叠上下文属性</strong> 的元素会被提升为单独的一层（z-index、position 等）</li> <li>需要 <strong>剪裁</strong> 的地方也会被创建为图层（如滚动条）</li></ol></li> <li>为每个图层生成 <strong>绘制列表</strong>，并将其提交到合成线程</li> <li>合成线程将图层分成 <strong>图块</strong>，并在 <strong>光栅化线程池</strong> 中将图块转换成位图
<ol><li>合成线程会按照 <strong>视口</strong> 附近的图块来优先生成位图</li> <li><strong>栅格化</strong> 过程会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化（GPU 进程）</li></ol></li> <li>合成线程发送绘制图块命令 <strong>DrawQuad</strong> 给浏览器进程</li> <li>浏览器进程根据 DrawQuad 消息 <strong>生成页面（绘制在内存中）</strong>，<strong>显示</strong> 页面</li></ol> <h3 id="生成-dom-树"><a href="#生成-dom-树" class="header-anchor">#</a> 生成 DOM 树</h3> <p>在渲染引擎内部，有一个叫 **HTML 解析器（HTMLParser）**的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构</p> <p><strong>HTML 解析器随着网络进程加载多少数据，就解析多少数据</strong></p> <p>生成 DOM 树流程：</p> <ol><li>通过分词器将网络进程传输过来的字节流转为 Token
<ol><li>分为 Tag Token（StartTag、EndTag）和文本 Token</li></ol></li> <li>将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中
<ol><li>HTML 解析器维护一个 <strong>Token 栈</strong></li> <li>如果分词器解析出来的是 <strong>StartTag Token</strong>，则压入栈，解析器为 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点</li> <li>如果分词器解析出来是 <strong>文本 Token</strong>，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点</li> <li>如果分词器解析出来的是 <strong>EndTag 标签</strong>，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成</li></ol></li></ol> <blockquote><p>遇到 JavaScript 代码会暂停 DOM 解析，先执行代码</p> <p>如果遇到需要下载的 JS 或 CSS 代码，浏览器会开启一个 <strong>预解析</strong> 线程提前下载这些文件</p></blockquote> <h3 id="渲染机制"><a href="#渲染机制" class="header-anchor">#</a> 渲染机制</h3> <h4 id="重排"><a href="#重排" class="header-anchor">#</a> 重排</h4> <p>通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫 <strong>重排</strong></p> <p><strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong></p> <ul><li>改变 DOM 树结构</li> <li>获取一些特定的值（offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight）</li></ul> <h4 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h4> <p>修改了元素的背景颜色，布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫 <strong>重绘</strong></p> <p><strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong></p> <p><strong>重排一定会重绘，重绘不一定重排</strong></p> <h4 id="合成"><a href="#合成" class="header-anchor">#</a> 合成</h4> <p>渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做 <strong>合成</strong></p> <p><strong>合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong></p> <p><strong>相对于重绘和重排，合成能大大提升绘制效率</strong></p> <p>合成主要分为：<strong>分层</strong>、<strong>分块</strong>、<strong>合成</strong> 三步</p> <p>分层流程：</p> <ol><li>分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为 <strong>层树</strong>（渲染流水线后续流程的基础结构）</li> <li>根据层树节点生成绘制指令，组合成一个绘制指令列表</li> <li>光栅化，按照绘制列表中的指令生成图片</li> <li>合成线程合成图片发送到后缓冲区</li></ol> <p>在分层基础上优化可 <strong>在 CSS 中使用 <code>will-change</code> 属性</strong> 来告诉渲染引擎元素将做的变换操作，从而<strong>提升渲染效率</strong></p> <p>分块技术则是采用 <strong>在首次合成图块的时候使用一个低分辨率的图片</strong> 的策略</p> <h3 id="优化渲染"><a href="#优化渲染" class="header-anchor">#</a> 优化渲染</h3> <ol><li>减少 JS 脚本执行时间
<ol><li>将一次执行的函数分解为多个任务，使得每次的执行时间不要过久</li> <li>采用 Web Workers（只能执行和 DOM 无关且耗时的操作）</li></ol></li> <li>避免 <strong>强制同步（强制将计算样式和布局操作提前到当前的任务中）</strong></li> <li>避免 <strong>布局抖动（多次执行强制布局和抖动操作）</strong></li> <li>合理利用 CSS 合成动画（will-change）</li> <li>避免频繁垃圾回收</li></ol> <h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <ul><li><strong>函数调用栈</strong> --- 当引擎第一次遇到 JS 代码时，会产生一个全局执行上下文并压入调用栈，后面每遇到一个函数调用，就会往栈中压入一个新的函数上下文，JS引擎会执行栈顶的函数，执行完毕后，弹出对应的上下文</li> <li><strong>宏任务</strong> --- setTimeout、setInterval、 setImmediate、 script（整体代码）、I/O 操作等，DOM 渲染后再触发</li> <li><strong>微任务</strong> --- process.nextTick、Promise、MutationObserver 等，DOM 渲染前会触发</li></ul> <h3 id="event-loop-机制"><a href="#event-loop-机制" class="header-anchor">#</a> Event-Loop 机制</h3> <ol><li>执行并出队一个 <strong>宏任务</strong>。注意如果是初始状态：调用栈空、微任务队列空，宏任务队列里有且只有一个 script 脚本（整体代码）。这时首先执行并出队的就是 script 脚本</li> <li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，<strong>可以产生新的宏任务和微任务，它们会分别被推入各自的任务队列里，这个过程本质上是队列的宏任务的执行和出队的过程</strong></li> <li>上一步我们出队的是一个 <strong>宏任务</strong>，这一步我们处理的是 <strong>微任务</strong>。但需要注意的是：当宏任务出队时，任务是 <strong>一个一个</strong> 执行的；而微任务出队时，任务是 <strong>一队一队</strong> 执行的（如下图所示）。因此，<strong>我们处理微任务队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空</strong></li> <li>执行 DOM 渲染操作，更新界面</li> <li>检查是否存在 Web worker 任务，如果有，则对其进行处理</li></ol> <h3 id="for-of"><a href="#for-of" class="header-anchor">#</a> for...of</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 定时算乘法</span>
<span class="token keyword">function</span> <span class="token function">multi</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>num <span class="token operator">*</span> num<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用 for...of ，可以让计算挨个串行执行</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token keyword">of</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 在 for...of 循环体的内部，遇到 await 会挨个串行计算</span>
        <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">multi</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="执行顺序"><a href="#执行顺序" class="header-anchor">#</a> 执行顺序</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
    <span class="token comment">// 这一句会同步执行，返回 Promise ，其中的 `console.log('async2')` 也会同步执行</span>
  <span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
  <span class="token comment">// 上面有 await ，下面就变成了“异步”，类似 cakkback 的功能（微任务）</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span>  <span class="token comment">// 6 </span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2'</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 异步，宏任务</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span> <span class="token comment">// 8</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 返回 Promise 之后，即同步执行完成，then 是异步代码</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// Promise 的函数体会立刻执行</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span> <span class="token comment">// 4</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 异步，微任务</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span> <span class="token comment">// 7</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span> <span class="token comment">// 5</span>

<span class="token comment">// 同步代码执行完之后，屡一下现有的异步未执行的，按照顺序</span>
<span class="token comment">// 1. async1 函数中 await 后面的内容 —— 微任务</span>
<span class="token comment">// 2. setTimeout —— 宏任务</span>
<span class="token comment">// 3. then —— 微任务</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h2 id="缓存机制"><a href="#缓存机制" class="header-anchor">#</a> 缓存机制</h2> <p>浏览器的缓存机制也就是 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的</p> <p><strong>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的HTTP 头中和请求结果一起返回给浏览器</strong></p> <p>浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中</p> <ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li> <li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul> <h3 id="缓存存放位置"><a href="#缓存存放位置" class="header-anchor">#</a> 缓存存放位置</h3> <p>缓存请求对应的 Size 值代表缓存存放的位置，分别为 <strong>from memory cache</strong> 和 <strong>from disk cache</strong></p> <p>from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存</p> <p>浏览器读取缓存的顺序为 <strong>memory –&gt; disk</strong></p> <ul><li><strong>内存缓存（from memory cache）</strong> --- 内存缓存具有两个特点，分别是 <strong>快速读取</strong> 和 <strong>时效性</strong> <ul><li>快速读取 --- 内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取</li> <li>时效性 --- 一旦该进程关闭，则该进程的内存则会清空</li></ul></li> <li><strong>硬盘缓存（from disk cache）</strong> --- 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行 I/O 操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢</li></ul> <h3 id="强制缓存"><a href="#强制缓存" class="header-anchor">#</a> 强制缓存</h3> <p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，其有三种结果：</p> <ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）</li> <li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存</li> <li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol> <p>控制强制缓存的 HTTP 字段分别是 <strong>Expires</strong> 和 <strong>Cache-Control</strong></p> <h4 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h4> <p>Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器 <strong>返回该请求结果缓存的到期时间</strong>，即再次发起该请求时，如果 <strong>客户端的时间小于 Expires 的值时，直接使用缓存结果</strong></p> <p>但如果客户端和服务端的时间发生误差，会导致缓存失效，所以 <strong>Cache-Control</strong> 已经在 1.1 版本完全替代它</p> <h4 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h4> <p>其取值：</p> <ul><li><code>public</code> --- 所有内容都将被缓存（客户端和代理服务器都可缓存）</li> <li><code>private</code> --- 所有内容只有客户端可以缓存（默认值）</li> <li><code>no-cache</code> --- 客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li> <li><code>no-store</code> --- 所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li> <li><code>max-age=xxx (xxx is numeric)</code> --- 缓存内容将在 xxx 秒后失效</li></ul> <p>在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于 expires 是更好的选择，<strong>所以同时存在时，只有 Cache-Control 生效</strong></p> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，其有两种结果：</p> <ol><li>协商缓存生效，返回 304</li> <li>协商缓存失效，返回 200 和请求结果结果</li></ol> <p>控制协商缓存的 HTTP 字段分别是 <strong>Last-Modified / If-Modified-Since</strong> 和 <strong>Etag / If-None-Match</strong></p> <h4 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" class="header-anchor">#</a> Last-Modified / If-Modified-Since</h4> <p>Last-Modified 是服务器响应请求时，返回 <strong>该资源文件在服务器最后被修改的时间</strong></p> <p>If-Modified-Since 则是客户端再次发起该请求时，<strong>携带上次请求返回的 Last-Modified 值</strong>，通过此字段值 <strong>告诉服务器该资源上次请求返回的最后被修改时间</strong></p> <p>服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比</p> <ol><li>若服务器的资源最后被修改时间 <strong>大于</strong> If-Modified-Since 的字段值，则重新返回资源，状态码为 200</li> <li>否则则返回 304，代表资源无更新，可继续使用缓存文件</li></ol> <h4 id="etag-if-none-match"><a href="#etag-if-none-match" class="header-anchor">#</a> Etag / If-None-Match</h4> <p>Etag 是服务器响应请求时，返回 <strong>当前资源文件的一个唯一标识（由服务器生成）</strong></p> <p>If-None-Match 是客户端再次发起该请求时，<strong>携带上次请求返回的唯一标识 Etag 值</strong>，通过此字段值 <strong>告诉服务器该资源上次请求返回的唯一标识值</strong></p> <p>服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比</p> <ol><li>一致则返回 304，代表资源无更新，继续使用缓存文件</li> <li>不一致则重新返回资源文件，状态码为 200</li></ol> <h3 id="总体过程"><a href="#总体过程" class="header-anchor">#</a> 总体过程</h3> <ol><li><p>先判断浏览器有没有缓存，若没缓存则向服务器请求资源</p></li> <li><p>若有缓存，根据 <code>Cache-Control: max-age</code> 或是 <code>Expires</code> 判断资源是否过期</p> <ol><li><p>如果资源没过期，则直接从缓存读取（强制缓存），此时在 Network 一栏可以看到资源对应的状态码为 <strong>200（from disk cache）或者是 200 （from memory cache）</strong></p></li> <li><p><code>Cache-Control</code> 优先级高于 <code>Expires</code></p></li> <li><p>如果资源过期了</p> <ol><li><p>查看上次资源的响应是否有 <code>Etag</code> 头部， 有的话发送请求，请求头为 <code>If-None-Match</code></p></li> <li><p>没有 <code>Etag</code> 的话，看上次资源的响应是否有 <code>Last-Modified</code>，有的话发送请求，请求头为 <code>If-Modified-Since</code></p></li> <li><p>如果命中了缓存，或者说资源没有发生改变，服务器会发送状态码为 **304（Not Modify）**的响应，告诉浏览器读取缓存中的资源</p> <p>如果未命中缓存，或者说资源发生了改变，服务器会发送状态码为 **200（OK）**的响应，并把资源作为响应的内容发送给浏览器</p></li></ol></li></ol></li></ol> <p><img src="https://raw.githubusercontent.com/jinle0703/img-host/master/blog/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E8%B5%84%E6%BA%90" alt=""></p> <h2 id="客户端存储"><a href="#客户端存储" class="header-anchor">#</a> 客户端存储</h2> <p><code>cookie</code> 和 <code>session</code> 都是用来跟踪浏览器用户身份的会话方式</p> <p><code>WebStorage</code> 的目的是克服由 <code>cookie</code> 所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。</p> <p><code>WebStorage</code> 提供了两种 API</p> <ul><li><code>localStorage</code>（本地存储）</li> <li><code>sessionStorage</code>（会话存储）</li></ul> <h3 id="cookie"><a href="#cookie" class="header-anchor">#</a> cookie</h3> <p>由服务器生成，保存在客户端，<strong>浏览器每次请求都会带上 <code>cookie</code></strong>，一般用于存储用于判断用户是否登录的 <code>sessionid</code></p> <p><strong>存储大小单个 <code>cookie</code> 不超过 4kb</strong></p> <p>cookie 属性：</p> <ul><li><code>name=value</code> —— <code>cookie</code> 是以键值对存储的
<ul><li><strong>name</strong> 是名称，<code>cookie</code> 一旦创建，名称便不可更改，一般名称不区分大小写</li></ul></li> <li><code>domain</code> —— 可以访问此 <code>cookie</code> 的域名</li> <li><code>path</code> —— 可以访问此 <code>cookie</code> 的页面路径</li> <li><code>expires/Max-Age</code> —— 此 <code>cookie</code> 超时时间
<ul><li>若设置其值为一个时间，那么当到达此时间后，此 <code>cookie</code> 失效（<strong>保存在硬盘中</strong>）</li> <li>不设置的话默认值是 <code>Session</code>，意思是 <code>cookie</code> 会和 <code>session</code> 一起失效（<strong>保存在内存中</strong>）</li></ul></li> <li><code>httponly</code> —— 若为 <code>true</code> 则不能通过前端访问此 <code>cookie</code></li> <li><code>secure</code> —— 设置是否只能通过 <code>https</code> 来传递此条 <code>cookie</code></li> <li><code>samesite</code> —— 三种模式限制第三方页面携带 <code>cookie</code></li></ul> <h3 id="session"><a href="#session" class="header-anchor">#</a> session</h3> <p>由服务器生成，保存在服务器端，一般用于保存用户登录信息</p> <p>当服务器收到请求需要创建 <code>session</code> 对象时：</p> <ol><li>首先会检查客户端请求中是否包含 <code>sessionid</code></li> <li>如果有 <code>sessionid</code>，服务器将根据该 <code>id</code> 返回对应 <code>session</code> 对象</li> <li>如果客户端请求中没有 <code>sessionid</code>，服务器会创建新的 <code>session</code> 对象，并把 <code>sessionid</code> 在本次响应中返回给客户端</li> <li>通常使用 cookie 方式存储 <code>sessionid</code> 到客户端，在交互中浏览器按照规则将 <code>sessionid</code> 发送给服务器</li></ol> <h3 id="localstorage"><a href="#localstorage" class="header-anchor">#</a> localStorage</h3> <p>由客户端生成，保存在客户端，常用于长期登录（判断用户是否已登录），适合长期保存在本地的数据</p> <p><code>localStorage</code> 的生命周期是永久的，关闭页面或浏览器之后 <code>localStorage</code> 中的数据也不会消失</p> <p><code>localStorage</code> 除非主动删除数据，否则数据永远不会消失</p> <p><code>localStorage</code> 的存储大小一般是 <code>5MB</code></p> <h3 id="sessionstorage"><a href="#sessionstorage" class="header-anchor">#</a> sessionStorage</h3> <p>由客户端生成，保存在客户端，<strong><code>sessionStorage</code> 的生命周期是在仅在当前会话下有效</strong>，常用于敏感账号一次性登录</p> <p><code>sessionStorage</code> 引入了一个浏览器窗口的概念，<code>sessionStorage</code> 是在同源的窗口中始终存在的数据</p> <p>只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在</p> <p>但是 <code>sessionStorage</code> 在关闭了浏览器窗口后就会被销毁；同时独立的打开同一个窗口同一个页面，<code>sessionStorage</code> 也是不一样的</p> <p><code>sessionStorage</code> 的存储大小一般是 5MB</p> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <h3 id="同源策略"><a href="#同源策略" class="header-anchor">#</a> 同源策略</h3> <p><strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源</strong>，浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的</p> <p>两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，即 <strong>同源策略</strong></p> <ol><li>在 DOM 层面，限制了来自不同源的 JS 脚本对当前 DOM 对象读和写的操作</li> <li>在数据层面，限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据</li> <li>在网络层面，限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点</li></ol> <h3 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h3> <p>原理就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制，通过 <code>&lt;script&gt;</code> 标签 src 属性，发送带有callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据。</p> <p>客户端</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
	<span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token comment">//do something</span>
	<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com/index?callback=doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>服务端</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">doSomething(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>myJson<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)</span><span class="token template-punctuation string">`</span></span> <span class="token comment">// 传参</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>缺点</strong>：只能发送 GET 请求，安全性差</p> <h3 id="cors-跨域资源共享"><a href="#cors-跨域资源共享" class="header-anchor">#</a> CORS（跨域资源共享）</h3> <p>CORS 需要浏览器和服务器同时支持</p> <p>浏览器将 CORS 跨域请求分为简单请求和非简单请求</p> <p>需同时满足以下两个条件，即为简单请求</p> <p>1、方法为 <code>head</code>、<code>get</code>、<code>post</code></p> <p>2、请求 Header 是 <code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code>（只限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）</p> <h4 id="简单请求"><a href="#简单请求" class="header-anchor">#</a> 简单请求</h4> <p>浏览器直接发出 CORS 请求，在头信息中增加一个 <code>Origin</code> 字段，来表明此次请求来自哪个源</p> <p>服务器根据这个值，决定是否同意这次请求，处理结果分两种情况：</p> <ul><li>拒绝
<ul><li>如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应</li> <li>浏览器发现，这个回应的头信息没有包含 <code>Access-Control-Allow-Origin</code> 字段，就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获</li></ul></li> <li>同意
<ul><li>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出这个关键的头信息字段 <code>Access-Control-Allow-Origin</code>，它的值要么是请求时的 <code>Origin</code> ，要么是 *（表示接收任意域名）</li> <li>同时还有可选字段<code>Access-Control-Allow-Credentials</code>，设置为 <code>true</code> 时，表示允许发送 <code>cookie</code>，此时 <code>Access-Control-Allow-Origin</code> 不能为 *，此字段默认为 <code>false</code></li></ul></li></ul> <h4 id="非简单请求"><a href="#非简单请求" class="header-anchor">#</a> 非简单请求</h4> <p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 <code>put</code> 或 <code>delete</code>，或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code></p> <p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为 <strong>预检</strong> 请求</p> <p>预检的作用在于，确认当前网页所在的域名是否在服务器的许可名单之中、明确可以使用的 HTTP 请求方法和头信息字段；只有在这个请求返回成功的情况下，浏览器才会发出正式的请求</p> <p>预检使用的方法时 <code>options</code>，此方法是用来询问的，此方法包含以下几个字段</p> <ul><li><p><code>Origin</code>：表示请求源</p></li> <li><p><code>Access-Control-Request-Method</code>：用来表示非简单请求的请求方法</p></li> <li><p><code>Access-Control-Request-Headers</code>：用来表示非简单请求的额外头部，例如自定义头部</p></li></ul> <p>预检请求的回应包含以下字段</p> <ul><li><p><code>Access-Control-Allow-Methods</code>：表示服务器支持的所有跨域请求方法</p></li> <li><p><code>Access-Control-Max-Age</code>：表示本次预检请求的有效期</p></li> <li><p><code>Access-Control-Allow-Headers</code>：表示服务器支持的所有头信息字段</p></li> <li><p><code>Access-Control-Allow-Credentials</code>：表示 <code>cookie</code> 的设置</p></li></ul> <h3 id="document-domaim"><a href="#document-domaim" class="header-anchor">#</a> document.domaim</h3> <p><strong>此方案仅限主域相同，子域不同的跨域应用场景，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式</strong>，只需要给页面添加 <code>document.domain ='test.com'</code> 表示二级域名都相同就可以实现跨域</p> <p>实现原理：两个页面都通过 js 强制设置 <code>document.domain = 'example.com'</code> ，就实现了同域，可以共享 cookie</p> <h3 id="postmessage"><a href="#postmessage" class="header-anchor">#</a> postMessage</h3> <p>从 H5 开始支持，通过注册监听信息的 Message 事件、调用发送信息的 postMessage 方法，可以实现跨窗口通信</p> <h4 id="发送"><a href="#发送" class="header-anchor">#</a> 发送</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>otherWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> targetOrigin<span class="token punctuation">,</span> <span class="token punctuation">[</span>transfer<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p>otherWindow --- 对目标窗口的引用</p></li> <li><p>message --- 要发送的消息</p></li> <li><p>targetOrigin --- 限定消息接受范围，一般是字符串或者 URI，星号 * 则意味着不限制</p></li></ul> <h4 id="接收信息"><a href="#接收信息" class="header-anchor">#</a> 接收信息</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> data <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window<span class="token punctuation">.</span>addEventListener <span class="token operator">!=</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span>onmessage<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window<span class="token punctuation">.</span>attachEvent <span class="token operator">!=</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token string">'onmessage'</span><span class="token punctuation">,</span> onmessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="服务端代理"><a href="#服务端代理" class="header-anchor">#</a> 服务端代理</h3> <p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域</p> <ul><li><code>webpack</code> 可以配置 <code>proxy</code> 来获取代理能力</li> <li>脚手架搭建的项目可以自行配置（vue-cli）</li> <li>第三方代理库</li></ul> <h3 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h3> <p>WebSocket 是 HTML5 开始提供的⼀种在单个 TCP 连接上进⾏全双⼯通讯的协议，可以实现跨域访问</p> <p>这种方式本质没有使用了 HTTP 的响应头，因此也没有跨域的限制</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/JINLE0703/blog/edit/main/docs/frontend/浏览器相关.md" target="_blank" rel="noopener noreferrer">edit this page</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2021/4/6 上午3:39:25</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/frontend/微信小程序.html" class="prev">
        微信小程序
      </a></span> <span class="next"><a href="/blog/frontend/前端工程化.html">
        前端工程化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.bfa839b2.js" defer></script><script src="/blog/assets/js/2.645db33a.js" defer></script><script src="/blog/assets/js/24.8b11f7a9.js" defer></script>
  </body>
</html>
