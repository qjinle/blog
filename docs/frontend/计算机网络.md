---
title: 计算机网络
lang: zh-CN
---

## 层次结构

### OSI 七层模型

- 应用层 --- 为计算机用户提供接口和服务
- 表示层 --- 数据处理（编码解码、加密解密等）
- 会话层 --- 管理（建立、维护、重连）通信会话
- 传输层 --- 管理端到端的通信连接
- 网络层 --- 数据路由（决定数据在网络的路径）
- 数据链路层 --- 管理相邻节点之间的数据通信
- 物理层 --- 数据通信的光电物理特性

### TCP/IP 四层模型

- 应用层（应用层、表示层、会话层）（HTTP/FTP...）
- 传输层（TCP/UDP）
- 网络层（IP/ICMP）
- 网络接口层（数据链路层、物理层）

## 应用层

### DNS 域名系统

将主机名和域名转换为 IP 地址

### DHCP 协议

动态主机设置协议，属于局域网协议，应用 UDP 协议

为临时加入局域网设备提供临时 IP 地址

### HTTP 协议

超文本传输协议

> 详情见 [HTTP 协议](#http)

## 传输层

### UDP 协议

用户数据包协议

UDP 中一个最重要的信息是 **端口号**，通过端口号 UDP 就能把指定的数据包发送给指定的程序

- 面向无连接协议
- 不保证可靠的交付数据
- 面向报文传输（对数据不做处理）
- 没有拥塞控制
- 首部开销小

报文结构为：

1. 16 位源端口号
2. 16 位目的端口号
3. 16 位 UDP 长度
4. 16 位 UDP 校验和

### TCP 协议

传输控制协议

- 面向连接协议
- 一个连接有两端（点对点通信）
- 提供可靠的传输服务
- 提供全双工通信
- 面向字节流

#### 报文结构

![image-20210111155643136](https://raw.githubusercontent.com/jinle0703/img-host/master/blog/TCP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png)

1. 序号 --- 占 32 位，数据首字节序号

2. 确认号 --- 占 32 位，期望收到数据的首字节序号（确认号 ack = N，表示 N-1 序号的数据都已经收到）

3. 数据偏移 --- 占 4 位，数据偏离首部的距离

4. TCP 标记 --- 占 6 位，见下表

   | 标记 | 含义                                    |
   | :--: | :-------------------------------------- |
   | URG  | 紧急位，置 1 时，表示有紧急数据         |
   | ACK  | 确认位，置 1 时，表示确认号生效         |
   | PSH  | 推送位，置 1 时，尽快把数据交付给应用层 |
   | RST  | 重置位，置 1 时，重新建立连接           |
   | SYN  | 同步位，置 1 时，表示连接请求报文       |
   | FIN  | 终止位，置 1 时，表示释放连接           |

5. 窗口 --- 占 16位，指明允许对方发送的数据量

6. 紧急指针 --- URG=1 时，指定紧急数据在报文的位置

#### TCP 生命周期

1. **首先，建立连接阶段**。这个阶段是通过 **三次握手** 来建立客户端和服务器之间的连接。
2. **其次，传输数据阶段**。在该阶段，**接收端需要对每个数据包进行确认操作**。接收端在接收到数据包之后，需要发送确认数据包给发送端。
   1. 当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的 **重发机制**。
   2. 一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
3. **最后，断开连接阶段**。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段 **四次挥手** 来保证双方都能断开连接。

#### 三次握手

1. **客户端** 给 **服务端** 发送报文，**服务端** 知道自己能接收到 **客户端** 发送的报文

   该报文的 SYN=1， seq=x

2. **服务端** 给 **客户端** 发送报文，**客户端** 知道自己能接收 **服务端** 发送的报文，知道自己发送的报文能被 **服务端** 接收

   该报文的 SYN=1, ACK=1，ack(确认号)=x+1，seq=y

3. **客户端** 给 **服务端** 发送报文，**服务端** 知道自己发送的报文能被 **客户端** 接收。

   该报文的 ACK=1，ack(确认号)=y+1，seq=x+1

##### 为什么不是两次握手

为了确认客户端和服务端都可以请求和响应

主要是为了防止已经失效的连接请求报文突然又传送到了服务端，从而产生错误

#### 四次挥手

1. 若 **客户端** 认为数据发送完成，则它需要向 **服务端** 发送连接释放请求。

   该报文的 FIN=1，seq=u

2. **服务端** 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 **CLOSE_WAIT** 状态，表示 **客户端** 到 **服务端** 的连接已经释放，**不接收 客户端 发的数据**了。但是因为 **TCP 连接时双向的**，所以 **服务端** 仍旧可以发送数据给 **客户端**。

   该报文的 ACK=1，seq=v，ack=u+1

3. B 如果此时还有没发完的数据会继续发送，完毕后会向 **客户端** 发送连接释放请求，然后 **服务端** 便进入 **LAST-ACK** 状态。

   该报文的 FIN=1，ACK=1，seq=w，ack=u+1

   > PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。

4. **客户端** 收到释放请求后，向 **服务端** 发送确认应答，此时 A 进入 **TIME-WAIT** 状态（如果没有 **TIME-WAIT** 状态，若报文因为网络问题没有送达，则服务端不会正常关闭）。该状态会持续 **2MSL**（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 **服务端** 的重发请求的话，就进入 **CLOSED** 状态。当 **服务端** 收到确认应答后，也便进入 **CLOSED** 状态。

   该报文的 ACK=1，seq=u+1，ack=w+1

### UDP vs TCP

TCP 是面向连接的传输层协议，而 UDP 是面向无连接的传输层协议

TCP 通过三次握手/四次挥手来保障传输，不过因此速度比 UDP 慢

#### UDP 存在问题

- 数据包在传输过程中容易丢失
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件

#### TCP 优势

- 对于数据包丢失的情况，TCP 提供重传机制
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件

## 网络层

### IP 协议

IP 是整个 TCP/IP 协议族的核心，也是构成互联网的基础。IP 位于 TCP/IP 模型的网络层（相当于 OSI 模型的网络层），对上可载送传输层各种协议的信息，例如 TCP、UDP 等；对下可将 IP 信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。

- 使得复杂的实际网络变为一个虚拟互连的网络
- 使得网络层可以屏蔽底层细节而专注网络层的数据转发
- 解决了在虚拟网络中数据报传输路径的问题

<img src="https://raw.githubusercontent.com/jinle0703/img-host/master/blog/ip%E5%8D%8F%E8%AE%AE.png" alt="image-20210109112115972"  />

1. 版本 --- IP 协议的版本，通信双方的版本必须一致，当前主流版本是 4 ，即 IPv4 也有 IPv6
2. 首部位长度 --- 最大数值为 15 ，表示的是 IP 首部长度，IP 首部最大长度为 60 字节
3. 总长度 --- 最大数值为 65535 ，表示的是 IP 数据报总长度（ IP 首部 +IP 数据）
4. TTL --- 表明 IP 数据报文在网络中的寿命，每经过一个设备， TTL 减 1 ，当 TTL=0 时，网络设备必须丢弃该报文
5. 协议 --- 表明 IP 数据所携带的具体数据是什么协议的（ TCP 、 UDP 等）
6. 首部校验和 --- 校验 IP 首部是否有出错

#### 转发流程

网络层 ---> 数据链路层 ---> 物理层 ---> 物理层 ---> 数据链路层 ---> 网络层

1. 发送端 A 发出目的地为接收端 D 的 IP 数据报
2. 查询路由表发现下一跳为路由 B
3. 发送端 A 将 IP 数据包交给数据链路层，并告知目的 MAC 地址是 B
4. 数据链路层填充源 MAC 地址 A 和目的 MAC 地址 B
5. 数据链路层通过物理层发送给路由 B
6. 路由 B 的数据链路层接收到数据帧， 把帧数据交给网络层
7. 重复 2、3、4、5 直至接收端 D 收到数据

### (R)ARP 协议

ARP 协议 --- 地址解析协议，把网络层 IP 地址 解析为 数据链路层 MAC 地址

RARP 协议 --- 逆地址解析协议

ARP 缓存表 ---缓存了 IP 地址到硬件地址之间的映射关系（有期限），判断缓存表有没有映射关系而决定数据链路层的传输方式

### 网络地址转换 NAT 技术

用于多个主机通过一个公有 IP 访问互联网的私有网络中

NAT 减缓了 IP 地址的消耗，但是增加了网络通信的复杂度

通过把内部地址映射到外部网络的一个 IP 地址的不同**端口**上

### ICMP 协议

用于**报告错误信息或者异常情况**，此协议报文封装在 IP 数据报文里

可分为 **差错报告报文** 和 **询问报文**

当 IP 报文协议字段为 **1** 时，表示此报文携带的数据为 ICMP 协议

![image-20210109181919320](https://raw.githubusercontent.com/jinle0703/img-host/master/blog/ICMP%E5%8D%8F%E8%AE%AE.png)

#### 差错报告报文

|     类型值      |     报文类型     | 具体代码 |
| :-------------: | :--------------: | :------: |
| 3（终点不可达） |    网络不可达    |    0     |
| 3（终点不可达） |    主机不可达    |    1     |
|   5（重定向）   |   对网络重定向   |    0     |
|   5（重定向）   |   对主机重定向   |    1     |
|       11        |     传输超时     |    -     |
|       12        |    坏的 IP 头    |    0     |
|       12        | 缺少其他必要参数 |    1     |

#### 询问报文

| 类型值 |     报文类型     | 具体代码 |
| :----: | :--------------: | :------: |
|  0或8  |  回送请求或应答  |    -     |
| 13或14 | 时间戳请求或应答 |    -     |

### 自治系统(AS)

处于一个管理机构下的网络设备群，AS 内部网络自行管理， AS 对外提供一个或者多个出（入）口

自治系统内部路由的协议称为**内部网关协议（RIP 、 OSPF）**，外部路由的协议称为：**外部网关协议（BGP）**

### RIP 协议

使用 DV 算法的一种路由协议

协议把网络的 **跳数** 作为 DV 算法的距离，每隔 30s 交换一次路由信息，跳数 >15 的路由则为不可达路由

### OSPF 协议

开放最短路径优先协议，其核心是 **Dijkstra 算法**

其特点为：

- 向所有的路由器发送消息（Dijkstra 算法）
- 消息描述该路由器与相邻路由器的链路状态
- 只有链路状态发生变化时，才发送更新信息

### BGP 协议

边际网关协议，能够找到一条到达目的**比较好**的路由

AS 之间通过 **BGP 发言人** 来进行路由信息的交换

## 数据链路层

### 封装成帧

发送端在网络层的一段数据前后添加特定标记形成“帧”

![](https://raw.githubusercontent.com/jinle0703/img-host/master/blog/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png)

### 透明传输

对控制字符（帧头、帧尾）转义

### 差错检测

- 奇偶校验码
- 循环冗余校验码 CRC --- 根据传输或保存的数据而**产生固定位数校验码**

> 数据链路层只进行数据的检测，不进行纠正

### MTU

最大传输单元，数据链路层的数据帧也不是无限大的

**路径 MTU** 由链路中 MTU 的最小值决定

### MAC 地址

物理地址、硬件地址，每个设备都拥有唯一的 MAC 地址

MAC 地址共48位，使用十六进制表示，如 `30-B4-9E-ED-85-CA`

### 以太网协议

完成 **相邻设备** 的数据帧传输

1. 发送端通过网卡发出数据帧
2. 数据帧到达路由器，路由器取出前 6 字节（接收端 MAC 地址）
3. 路由器匹配 MAC 地址表，找到相应网络接口
4. 路由器往该接口发送数据帧
5. 如果路由器匹配不到相应 MAC 地址，则广播数据包到除发送端以外的端口，并将收到回应记录在 MAC 地址表

## 物理层

为了连接不同的物理设备，传输比特流（高低电平、数字信号）

### 信道

往一个方向传送信息的媒体，一条通信电路包含一个接收信道和一个发送信道

- 单工通信信道 --- 只能一个方向通信，没有反方向反馈的信道
- 半双工通信信道 --- 双方都可以发送和接收信息，不能双方同时发送，也不能同时接收
- 全双工通信信道 --- 双方都可以同时发送和接收信息

### 分用-复用技术

## HTTP

### 版本

#### HTTP/1.1

HTTP/1.1 相对于 HTTP/1.0 做了以下升级：

1. 改进 **持久连接**
   1. 一个 TCP 连接上可以传输多个 HTTP 请求
   2. 最多同时维护 6 个持久连接
   3. 只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持
   4. 减少了服务器额外的负担，并提升整体 HTTP 的请求时长
2. 不成熟的 **HTTP 管线化**
   1. 如果 TCP 请求通道中某个请求没有返回，会阻塞后面的请求，即 **队头阻塞**
   2. 管线化是指将多个 HTTP 请求整批提交给服务器
   3. 可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求
3. 提供 **虚拟主机支持**
   1. 解决多个单独域名共用一个 IP 地址
   2. 请求头中添加 **Host** 字段表示当前域名地址
4. 对动态生成的内容提供完美支持，引入 **Chunk transfer 机制**
   1. 服务器会将数据分割成若干个任意大小的数据块
   2. 每个数据块发送时会附上上个数据块的长度
   3. 最后使用一个零长度的块作为发送数据完成的标志
5. 提供了与 **身份认证**、**状态管理** 和 **Cache 缓存** 等机制相关的请求头和响应头

HTTP/1.1 存在最主要的问题是 **对带宽的利用率低**，有以下三个原因：

1. **TCP 的慢启动**（一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态）
   1. 慢启动可以减少网络拥塞
   2. 但会造成首次渲染页面时间长
2. **同时开启了多条 TCP 连接，这些连接会竞争固定的带宽**
3. **队头阻塞问题没有完美解决**

#### HTTP/2

HTTP/2 相对于 HTTP/1.1 做了以下升级：

1. 添加了一个 **二进制分帧层**，且 **一个域名只使用一个 TCP 长连接**
   1. 浏览器准备好请求数据，包括了请求行、请求头、请求体等信息
   2. 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器
   3. 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息
   4. 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层
   5. 二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器
   6. 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求
2. 引入 **多路复用机制** 实现资源 **并行传输**
3. 可以设置请求 **优先级**
4. **服务器推送**，允许服务器主动向客户端 push 资源，提高首次打开速度
5. **头部压缩**，提升传输效率

HTTP/2 存在的问题：

1. TCP 队头阻塞问题，丢包率达到 2% 时，传输效率比 HTTP/1.1 差
2. TCP 建立连接握手次数造成的延时（大概需要 3~4 个 RTT）
3. TCP 协议僵化（新协议的数据经过中间件超时会被丢弃）

#### HTTP/3

为了解决 HTTP/2 存在的 TCP 协议相关的缺陷，HTTP/3 采用了 **UDP 协议 + QUIC 协议**

QUIC 协议可以看成是集成了 TCP + HTTP/2 的多路复用 +TLS 等功能的一套协议，QUIC 协议有以下几点功能：

1. **实现了类似 TCP 的流量控制、传输可靠性的功能**，如数据包重传、拥塞控制以及其他一些 TCP 中存在的特性
2. **集成了 TLS 加密功能**，减少了握手花费的 RTT
3. **实现了 HTTP/2 中的多路复用功能**，实现同一个物理连接上多个独立连接的逻辑数据流，实现数据流单独传输
4. **实现了快速握手功能**

### 状态码

#### 分类

- 1xx：服务器收到请求，正在处理
- 2xx：请求成功
- 3xx：需要进行附加操作（重定向）
- 4xx：客户端错误
- 5xx：服务端错误

#### 常用状态码

- 200 --- 成功
- 204 --- 请求成功，没有资源返回
- 206 --- 客户端进行范围请求，服务端成功执行这部分请求
- 301 --- 永久重定向（配合location，浏览器自动处理）（如：换域名）
- 302 --- 临时重定向（配合location，浏览器自动处理）（网站维护）
- 304 --- 资源未被修改
- 400 --- 客户端请求报文语法错误
- 401 --- 客户端认证身份失败
- 403 --- 被服务器拒绝，没有权限
- 404 --- 资源未找到
- 500 --- 服务器错误
- 502 --- 网关错误
- 503 --- 服务器超负载或停机维护
- 504 --- 网关超时

### 首部字段

#### 通用首部

`Cache-Control`：控制缓存的行为

指令的参数是可选的，多个指令之间通过“,”分隔。

```
Cache-Control: private, max-age=0, no-cache
```

|      请求指令      |  参数  |             说明             |
| :----------------: | :----: | :--------------------------: |
|      no-cache      |   无   |    强制向源服务器再次验证    |
|      no-store      |   无   |  不缓存请求或响应的任何内容  |
|   max-age = [秒]   |  必需  |      响应的最大 Age 值       |
| max-stale( = [秒]) | 可省略 |       接收已过期的响应       |
|  min-fresh = [秒]  |  必需  | 期望在指定时间内的响应仍有效 |
|    no-transform    |   无   |     代理不可更改媒体类型     |
|   only-if-cached   |   无   |        从缓存获取资源        |
|  cache-extension   |        |     新指令标记（token）      |

|     响应指令     |  参数  |                      说明                      |
| :--------------: | :----: | :--------------------------------------------: |
|      public      |   无   |            可向任意方提供响应的缓存            |
|     private      | 可省略 |              仅向特定用户返回响应              |
|     no-cache     | 可省略 |            缓存前必须先确认其有效性            |
|     no-store     |   无   |           不缓存请求或响应的任何内容           |
|   no-transform   |   无   |              代理不可更改媒体类型              |
| must-revalidate  |   无   |        可缓存但必须再向源服务器进行确认        |
| proxy-revalidate |   无   | 要求中间缓存服务器对缓存的响应有效性再进行确认 |
|  max-age = [秒]  |  必需  |               响应的最大 Age 值                |
| s-maxage = [秒]  |  必需  |        公共缓存服务器响应的最大 Age 值         |
| cache-extension  |        |              新指令标记（token）               |

`Connection`：控制不再转发给代理的首部字段、管理持久连接

```
Connection: Keep-Alive
```

`Date`：创建报文的日期时间

`Pragma`：HTTP/1.1 之前版本的历史遗留字段

`Trailer`：报文末端的首部一览

`Transfer-Encoding`：指定报文主体的传输编码方式

`Upgrade`：升级为其他协议，使用时需指定 `Connection:Upgrade`

`Via`：代理服务器的相关信息，用于追踪客户端与服务器之间的请求和响应报文的传输路径

`Warning`：错误通知

```
Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
```

#### 请求首部

`Accept`：用户代理可处理的媒体类型

```
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

`Accept-Charset`：优先的字符集

`Accept-Encoding`：浏览器可接收的压缩算法，如 gzip

`Accept-Languange`：浏览器可接收的语言，如 zh-CN

`Authorization`：Web 认证信息，用于告知服务器用户代理的认证信息

通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 `Authorization` 加入请求中。

`Expect`：期待服务器的特定行为

`From`：用户的电子邮箱地址

`Host`：域名，告知服务器请求的资源所处的互联网主机名和端口号。

`If-Match`：比较实体标记（ETag），当 `If-Match` 和 `ETag` 的值一样时服务器才会接收请求

`If-Modified—Since`：比较资源更新时间（Last-Modified），若 `If-Modified—Since` 时间在资源更新时间之前，则希望服务器处理请求返回资源，若 `If-Modified—Since` 时间在资源更新时间之后，则直接返回 304

`If-None-Match`：比较实体标记（ETag），`If-None-Match` 和 `ETag` 不一致时（说明已更新），服务器处理请求返回资源

`If-Range`：资源未更新时发送实体 Byte 的范围请求

`If-Unmodified-Since`：比较资源的更新时间（与 If-Modified-Since 相反）

`Max-Forwards`：最大传输逐跳数

`Proxy-Authorization`：代理服务器要求客户端的认证信息

`Range`：实体的字节范围请求

`Referer`：对请求中 URI 的原始获取方

`TE`：传输编码的优先级

`User-Agent(UA)`：浏览器信息

`Cookie`：服务器接收到的 Cookie 信息

#### 响应首部

`Accept-Ranges`：是否接受字节范围请求

`Age`：推算资源创建经过时间，告知客户端源服务器在多久前创建了响应。字段值的单位为秒

`ETag`：将资源以字符串的形式做唯一标识的方式，服务器会为每份资源分配对应的 `ETag` 的值

`Location`：令客户端重定向至指定的 URI，一般配合 3XX 的响应使用

`Proxy-Authenticate`：代理服务器对客户端的认证信息

`Retry-After`：告知客户端多久之后再发送请求

`Server`：HTTP 服务器的安装信息

`Vary`：代理服务器缓存的管理信息

`WWW-Authenticate`：服务器对客户端的认证信息

`Set-cookie`：  开始状态管理所使用的 Cookie 信息

```
Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;
```

|   **属性**   |                             说明                             |
| :----------: | :----------------------------------------------------------: |
|  NAME=VALUE  |              赋予 Cookie 的名称和其值（必需项）              |
| expires=DATE |    Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）    |
|  path=PATH   | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） |
| domain=域名  | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） |
|    Secure    |             仅在 HTTPS 安全通信时才会发送 Cookie             |
|   HttpOnly   |        加以限制，使 Cookie 不能被 JavaScript 脚本访问        |

#### 实体首部

`Allow`：资源可支持的 HTTP 方法，不支持返回 405

`Content-Encoding`：告知客户端服务器对实体的主体部分选用的内容编码方式

`Content-Language`：告知客户端实体主体使用的自然语言

`Content-Length`：实体主体的大小

`Content-Location`：替代对应资源的 URI

`Content-MD5`：一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达

`Content-Range`：针对范围请求，返回响应时使用的首部字段，知客户端作为响应返回的实体的哪个部分符合范围请求

`Content-Type`：实体主体的媒体类型

`Expires`：资源失效的日期

缓存服务器在接收到含有首部字段 `Expires` 的响应后，会以缓存来应答请求，在 `Expires` 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后， 缓存服务器在请求发送过来时，会转向源服务器请求资源。

`Last-Modified`：资源最后修改的时间

## HTTP 缓存

http 缓存指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。

使用 http 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。

web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。

### 浏览器请求资源时

1. 先判断浏览器有没有缓存，若没缓存则向服务器请求资源

2. 若有缓存，根据 `Cache-Control: max-age` 或是 `Expires` 判断资源是否过期。

   1. 如果资源没过期，则直接从缓存读取（强制缓存），此时在 Network 一栏可以看到资源对应的状态码为 **200（from disk cache）或者是 200 （from memory cache）**

      比如，资源没过期的时候我们打开新的页面，资源会从硬盘缓存中读取（from disk cache）；如果我们此时又刷新页面，资源会从内存缓存中读取（from memory cache）

   2. 如果资源过期了

      1. 查看上次资源的响应是否有 `Etag` 头部， 有的话发送请求，请求头为 `If-None-Match`

      2. 没有 `Etag` 的话，看上次资源的响应是否有 `Last-Modified`，有的话发送请求，请求头为 `If-Modified-Since`。

      3. 如果命中了缓存，或者说资源没有发生改变，服务器会发送状态码为 **304（Not Modify）**的响应，告诉浏览器读取缓存中的资源。

         如果未命中缓存，或者说资源发生了改变，服务器会发送状态码为 **200（OK）**的响应，并把资源作为响应的内容发送给浏览器。

## HTTPS

HTTPS = HTTP + SSL(安全套接层)/TLS(安全传输协议)

### HTTP 缺点

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，内容可能遭遇伪造
- 无法证明报文的完整性

所以 HTTPS = HTTP + 加密 + 认证 + 完整性保护

### 混合加密机制

HTTPS 采用**共享密钥加密（对称加密）**和**公开密钥加密（非对称加密）**两者混合并用的加密机制

1. 使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥
2. 确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信

> 公开密钥加密处理起来比共享密钥加密效率要低，所以这样做可以提升效率

### HTTPS 通信原理

服务器端的公钥和私钥，用来进行非对称加密

客户端生成的随机密钥，用来进行对称加密

1. 客户端发送 Client Hello 文开始 SSL 通信。报文中包含客户端支持的 **SSL 版本、加密组件列表、client-random（随机数1）**
2. 服务器可进行 SSL 通信时，以 Server Hello 报文作为应答。报文中包含 **SSL 版本、加密组件（从客户端发来的报文中筛选出来的）、service-random（随机数2）**
3. 服务器发送 Certificate 报文。报文包含 **公钥证书**
4. 服务器发送 Server Hello Done 报文通知客户端信息发送结束
5. 客户端 **验证证书的合法性**
   1. 先用CA的公钥解密被加密过后的证书，能解密则说明证书没有问题
   2. 然后通过证书里提供的摘要算法进行对数据进行摘要，然后通过自己生成的摘要与服务端发送的摘要比对
   3. 如果验证通过，客户端计算产生随机数字计算得出的 **Pre-master 随机密码串（client-random + service-random）**，随后发送报文 Client Key Exchange 作为应答。报文中包含 **用服务器证书公钥加密 Pre-master 生成后的密码串**
   4. **此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数与自己计算产生的 Pre-master，从而计算得到协商密钥 master secret**
6. 客户端继续发送 Change Cipher Spec 报文。该报文指示服务器之后的通信采用协商密钥进行加密通信
7. 客户端发送 Finished 报文。报文包含连接至今全部报文的整体校验值，用于服务器握手验证
8. 服务器接收到 Pre-master 后 **用密钥解密**，结合两个随机数生成 **master secret（协商密钥：client-random + service-random + Pre-master）**
9. 随后服务器发送 Change Cipher Spec 报文，指示客户端后续的通信都采用协商密钥进行加密通信
10. 服务器同样发送 Finished 报文
11. 服务器和客户端 Finished 报文交换后，SSL 连接就算建立完成
12. 随后开始使用 **master secret 进行加密通信**，即发送 HTTP 请求和响应
13. 最后由客户端断开连接。断开连接时发送 close_notify 报文

### 中间人攻击

![中间人攻击](https://raw.githubusercontent.com/jinle0703/img-host/master/blog/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.jpg)

1. 本地请求被劫持（如 DNS 劫持等），所有请求均发送到中间人的服务器。
2. 中间人服务器返回中间人自己的证书。
3. 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输。
4. 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密。
5. 中间人以客户端的请求内容再向正规网站发起请求。
6. 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据。
7. 中间人凭借与正规网站建立的对称加密算法对内容进行解密。
8. 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输。
9. 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密。

中间人攻击是因为服务端发送过来的公钥无法验证是不是真实的公钥，还是伪造的公钥。因此用CA签名的证书（公钥+签名）即可。
