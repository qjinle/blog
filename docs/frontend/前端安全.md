---
title: 前端安全
lang: zh-CN
---

## XSS

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

#### 存储型 XSS

存储在后端数据库，利用 HTML 插入

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

#### 反射型 XSS

存储在 URL，利用 HTML 插入

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等，一般是需要用户主动打开才能生效，攻击者往往诱导点击。

#### DOM 型 XSS

存储在 后端数据库/前端数据库/URL，利用前端 Javascript 插入

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

> 三种攻击的区别：
>
> 存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。
>
> DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

### 预防 XSS

XSS 攻击有两大要素：攻击者提交恶意代码、浏览器执行恶意代码。

##### **输入过滤**

输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题，在防范 XSS 攻击时应避免此类方法。

##### 纯前端渲染

1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（onload、javascript:xxx）

##### 转义 HTML

比较复杂，但如果拼接 HTML 是必要的话，就采用合适的转义库。

##### 其他

输入内容长度控制，可以增加 XSS 攻击的难度。

Cookie 设置为 HttpOnly 可以防止 XSS 劫持 Cookie。

验证码可以防止脚本冒充用户提交危险操作。

## CSRF

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一般攻击流程如下：

1. 受害者登录 a.com，并保留了登录凭证（Cookie）。
2. 攻击者引诱受害者访问了 b.com。
3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的Cookie。
4. a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
5. a.com 以受害者的名义执行了 act=xx。
6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。

#### GET 类型攻击

GET 类型的 CSRF 利用非常简单，只需要一个 HTTP 请求，浏览器会自动向以访问过的某网站发起一次 HTTP 请求。

#### POST 类型攻击

POST 类型的 CSRF 利用一个自动提交的表单，访问恶意页面后表单会自动提交，相当于模拟一次 POST 操作。

#### 链接类型攻击

链接类型的 CSRF 需要用户点击链接才会触发，这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击。

### 预防 CSRF

CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。

##### 验证码

CSRF 攻击往往是在用户不知情的情况下成功伪造请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求，而且因为 CSRF 攻击无法获取到验证码，因此通常情况下，验证码能够很好地遏制 CSRF 攻击。

##### 同源检测

在 HTTP 协议中，每一个异步请求都会携带两个 Header ，用于标记来源域名：

- Origin Header
- Referer Header

这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。

缺陷：某些情况下没有 Origin 和 Referer 

##### Cookie 的 SameSite 属性

SameSite 可以设置为三个值：Strict，Lax，None。

Strict 模式：浏览器禁止第三方请求携带 Cookie，比如 example.com 以外的网站在向 example.com/api/login 发送请求时不会发送 Cookie。

Lax 模式：相对宽松，只能在 `get 方法提交表单`或者`a 标签发送 get 请求`的情况下可以携带 Cookie，其他情况均不能。

None 模式：默认模式，请求自动带上 Cookie。（chrome 80 后可能默认模式会改为Lax）

##### CSRF Token

关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 Token，并在服务器端建立一个拦截器来验证这个 Token，如果请求中没有 Token 或者 Token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

1、服务器将 Token 返回到前端

2、前端发请求时携带这个 Token，对于 GET 请求，Token 将附在请求地址之后，这样 URL 就变成 `http://url?token=tokenvalue`。 而对于 `form` 标签发起的 POST 请求来说，要在 `form` 的最后加上：

```html
<input type=”hidden” name=”token” value=”tokenvalue”/>
```

3、服务器验证 Token 是否正确